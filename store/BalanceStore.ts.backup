import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { Storage } from "@plasmohq/storage"
import { ethers } from 'ethers'
import { useChainStore } from './ChainStore'

// ä»£å¸ä½™é¢æ¥å£
export interface TokenBalance {
  symbol: string
  name: string
  decimals: number
  balance: string
  formattedBalance: string
  contractAddress: string
  logoURI?: string
  priceUSD?: number
  valueUSD?: number
}

// è´¦æˆ·ä½™é¢çŠ¶æ€æ¥å£
export interface AccountBalance {
  address: string
  ethBalance: string
  formattedEthBalance: string
  ethPriceUSD?: number
  ethValueUSD?: number
  tokens: TokenBalance[]
  totalValueUSD?: number
  lastUpdated: number
}

// ä½™é¢æŸ¥è¯¢çŠ¶æ€æ¥å£
interface BalanceStoreState {
  // çŠ¶æ€
  balances: Record<string, AccountBalance> // address -> AccountBalance
  isLoading: boolean
  error: string
  selectedAccount: string

  // æ–¹æ³•
  updateSelectedAccount: (address: string) => void
  fetchEthBalance: (address: string) => Promise<void>
  fetchTokenBalance: (address: string, tokenAddress: string) => Promise<void>
  fetchAllBalances: (address: string, tokenAddresses?: string[]) => Promise<void>
  getBalanceByAddress: (address: string) => AccountBalance | undefined
  clearBalances: () => void
  refreshBalance: (address?: string) => Promise<void>
}

// ERC20 ABI (åªåŒ…å«éœ€è¦çš„å‡½æ•°)
const ERC20_ABI = [
  // æŸ¥è¯¢ä½™é¢
  'function balanceOf(address owner) view returns (uint256)',
  // æŸ¥è¯¢ä»£å¸ä¿¡æ¯
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)'
]

// å¸¸è§ä»£å¸åˆçº¦åœ°å€ (Sepolia æµ‹è¯•ç½‘)
const COMMON_TOKENS = {
  // Sepolia ä¸Šçš„æµ‹è¯•ä»£å¸
  '0xaf1dC8b5EeF71F764b0e9e568C5a5e6663A68531': 'TEST', // ç¤ºä¾‹æµ‹è¯•ä»£å¸
  '0x779877A7B0D9E8603169DdbD7836e478b4624789': 'WETH', // Wrapped Ether
}

// æ ¼å¼åŒ–ä½™é¢
const formatBalance = (balance: string, decimals: number): string => {
  try {
    const balanceBN = ethers.getBigInt(balance)
    const divisor = ethers.getBigInt(10 ** decimals)
    const beforeDecimal = balanceBN / divisor
    const afterDecimal = balanceBN % divisor

    if (afterDecimal === 0n) {
      return beforeDecimal.toString()
    }

    // æœ€å¤šæ˜¾ç¤º6ä½å°æ•°
    const afterDecimalStr = afterDecimal.toString().padStart(decimals, '0')
    const trimmedAfterDecimal = afterDecimalStr.substring(0, 6).replace(/0+$/, '')

    return `${beforeDecimal}.${trimmedAfterDecimal}`
  } catch (error) {
    console.error('æ ¼å¼åŒ–ä½™é¢å¤±è´¥:', error)
    return '0'
  }
}

// åˆ›å»º Zustand store
export const useBalanceStore = create<BalanceStoreState>()(
  persist(
    (set, get) => ({
      // åˆå§‹çŠ¶æ€
      balances: {},
      isLoading: false,
      error: "",
      selectedAccount: "",

      // æ›´æ–°é€‰ä¸­çš„è´¦æˆ·
      updateSelectedAccount: (address: string) => {
        set({ selectedAccount: address })
      },

      // è·å– ETH ä½™é¢ (æš‚æ—¶ç¦ç”¨ç½‘ç»œè¯·æ±‚ï¼Œé¿å…è®¤è¯å¼¹çª—)
      fetchEthBalance: async (address: string) => {
        try {
          set({ isLoading: true, error: "" })

          console.log(`ğŸ’° æš‚æ—¶è·³è¿‡ ETH ä½™é¢æŸ¥è¯¢ï¼Œé¿å…è®¤è¯å¼¹çª—: ${address}`)

          // æ¨¡æ‹Ÿä½™é¢æ•°æ®
          const mockBalance = "1.234567890"
          const selectedAccount = get().selectedAccount

          if (selectedAccount) {
            set(state => ({
              balances: {
                ...state.balances,
                [selectedAccount]: {
                  eth: mockBalance,
                  tokens: state.balances[selectedAccount]?.tokens || []
                }
              }
            }))
          }

          set({ isLoading: false })
          console.log(`âœ… æ¨¡æ‹Ÿ ETH ä½™é¢æŸ¥è¯¢å®Œæˆ: ${mockBalance} ETH`)
              balance = await Promise.race([
                provider.getBalance(address),
                timeoutPromise
              ])

              successfulRpcUrl = rpcUrl
              console.log(`âœ… RPC è¿æ¥æˆåŠŸ: ${rpcUrl}`)
              break

            } catch (error) {
              console.warn(`RPC ${rpcUrl} è¿æ¥å¤±è´¥:`, error)
              lastError = error instanceof Error ? error : new Error("Unknown error")
              continue
            }
          }

          if (balance === null || !provider) {
            throw lastError || new Error("æ‰€æœ‰ RPC ç«¯ç‚¹éƒ½æ— æ³•è¿æ¥")
          }

          const formattedBalance = ethers.formatEther(balance)

          // æ›´æ–°ä½™é¢çŠ¶æ€
          const currentBalances = get().balances
          const existingBalance = currentBalances[address] || {
            address,
            ethBalance: '0',
            formattedEthBalance: '0',
            tokens: [],
            lastUpdated: 0
          }

          const updatedBalance: AccountBalance = {
            ...existingBalance,
            ethBalance: balance.toString(),
            formattedEthBalance: formattedBalance,
            lastUpdated: Date.now()
          }

          set({
            balances: {
              ...currentBalances,
              [address]: updatedBalance
            },
            isLoading: false
          })

          console.log(`âœ… ETH ä½™é¢æŸ¥è¯¢æˆåŠŸ: ${address} -> ${formattedBalance} ETH`)

        } catch (error) {
          console.error("è·å– ETH ä½™é¢å¤±è´¥:", error)
          const errorMessage = error instanceof Error ? error.message : "è·å– ETH ä½™é¢å¤±è´¥"

          // æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
          let userFriendlyError = errorMessage
          if (errorMessage.includes("Failed to fetch") || errorMessage.includes("fetch")) {
            userFriendlyError = "ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•"
          } else if (errorMessage.includes("timeout")) {
            userFriendlyError = "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•"
          } else if (errorMessage.includes("insufficient funds")) {
            userFriendlyError = "ä½™é¢ä¸è¶³"
          }

          set({
            error: userFriendlyError,
            isLoading: false
          })

          // ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©åº”ç”¨ç»§ç»­è¿è¡Œ
          // throw error
        }
      },

      // è·å–ä»£å¸ä½™é¢
      fetchTokenBalance: async (address: string, tokenAddress: string) => {
        try {
          set({ isLoading: true, error: "" })

          // ä» ChainStore è·å–å½“å‰ç½‘ç»œé…ç½®
          const chainStore = useChainStore.getState()
          const networkConfig = chainStore.getNetworkConfig(chainStore.currentChainId)

          if (!networkConfig) {
            throw new Error("ç½‘ç»œé…ç½®æœªæ‰¾åˆ°")
          }

          // å°è¯•å¤šä¸ª RPC ç«¯ç‚¹
          let lastError: Error | null = null
          let contract: ethers.Contract | null = null
          let successfulRpcUrl = ""

          for (const rpcUrl of networkConfig.rpcUrls) {
            try {
              console.log(`ğŸ”— å°è¯•è¿æ¥ RPC (ä»£å¸æŸ¥è¯¢): ${rpcUrl}`)
              const provider = new ethers.JsonRpcProvider(rpcUrl)
              contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider)

              // è®¾ç½®è¾ƒçŸ­çš„è¶…æ—¶æ—¶é—´
              const timeoutPromise = new Promise<never>((_, reject) => {
                setTimeout(() => reject(new Error("ä»£å¸æŸ¥è¯¢è¶…æ—¶")), 5000)
              })

              // å¹¶è¡Œè·å–ä»£å¸ä¿¡æ¯
              const [balance, name, symbol, decimals] = await Promise.race([
                Promise.all([
                  contract.balanceOf(address),
                  contract.name().catch(() => "Unknown Token"),
                  contract.symbol().catch(() => "UNKNOWN"),
                  contract.decimals().catch(() => 18)
                ]),
                timeoutPromise
              ])

              const formattedBalance = formatBalance(balance.toString(), Number(decimals))

              // æ›´æ–°ä»£å¸ä½™é¢
              const currentBalances = get().balances
              const existingBalance = currentBalances[address] || {
                address,
                ethBalance: '0',
                formattedEthBalance: '0',
                tokens: [],
                lastUpdated: 0
              }

              const existingTokenIndex = existingBalance.tokens.findIndex(
                token => token.contractAddress.toLowerCase() === tokenAddress.toLowerCase()
              )

              const tokenBalance: TokenBalance = {
                name,
                symbol,
                decimals: Number(decimals),
                balance: balance.toString(),
                formattedBalance,
                contractAddress: tokenAddress
              }

              const updatedTokens = [...existingBalance.tokens]
              if (existingTokenIndex >= 0) {
                updatedTokens[existingTokenIndex] = tokenBalance
              } else {
                updatedTokens.push(tokenBalance)
              }

              const updatedBalance: AccountBalance = {
                ...existingBalance,
                tokens: updatedTokens,
                lastUpdated: Date.now()
              }

              set({
                balances: {
                  ...currentBalances,
                  [address]: updatedBalance
                },
                isLoading: false
              })

              console.log(`âœ… ä»£å¸ä½™é¢æŸ¥è¯¢æˆåŠŸ: ${address} -> ${formattedBalance} ${symbol}`)
              return // æˆåŠŸåç›´æ¥è¿”å›

            } catch (error) {
              console.warn(`ä»£å¸ RPC ${rpcUrl} æŸ¥è¯¢å¤±è´¥:`, error)
              lastError = error instanceof Error ? error : new Error("Unknown error")
              continue
            }
          }

          if (lastError) {
            throw lastError
          }

        } catch (error) {
          console.error("è·å–ä»£å¸ä½™é¢å¤±è´¥:", error)
          const errorMessage = error instanceof Error ? error.message : "è·å–ä»£å¸ä½™é¢å¤±è´¥"

          // æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
          let userFriendlyError = errorMessage
          if (errorMessage.includes("Failed to fetch") || errorMessage.includes("fetch")) {
            userFriendlyError = "ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•"
          } else if (errorMessage.includes("timeout")) {
            userFriendlyError = "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•"
          } else if (errorMessage.includes("call revert")) {
            userFriendlyError = "ä»£å¸åˆçº¦è°ƒç”¨å¤±è´¥"
          }

          set({
            error: userFriendlyError,
            isLoading: false
          })

          // ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©åº”ç”¨ç»§ç»­è¿è¡Œ
          // throw error
        }
      },

      // è·å–æ‰€æœ‰ä½™é¢ (ETH + å¸¸è§ä»£å¸)
      fetchAllBalances: async (address: string, tokenAddresses?: string[]) => {
        try {
          set({ isLoading: true, error: "" })

          // è·å– ETH ä½™é¢
          await get().fetchEthBalance(address)

          // è·å–ä»£å¸ä½™é¢
          const tokensToQuery = tokenAddresses || Object.keys(COMMON_TOKENS)

          for (const tokenAddress of tokensToQuery) {
            try {
              await get().fetchTokenBalance(address, tokenAddress)
            } catch (error) {
              console.warn(`è·å–ä»£å¸ ${tokenAddress} ä½™é¢å¤±è´¥:`, error)
              // ç»§ç»­å¤„ç†å…¶ä»–ä»£å¸ï¼Œä¸ä¸­æ–­æ•´ä¸ªæµç¨‹
            }
          }

        } catch (error) {
          console.error("è·å–æ‰€æœ‰ä½™é¢å¤±è´¥:", error)
          set({
            error: error instanceof Error ? error.message : "è·å–æ‰€æœ‰ä½™é¢å¤±è´¥",
            isLoading: false
          })
          throw error
        }
      },

      // æ ¹æ®åœ°å€è·å–ä½™é¢ä¿¡æ¯
      getBalanceByAddress: (address: string) => {
        return get().balances[address]
      },

      // æ¸…é™¤æ‰€æœ‰ä½™é¢
      clearBalances: () => {
        set({ balances: {} })
      },

      // åˆ·æ–°ä½™é¢
      refreshBalance: async (address?: string) => {
        const targetAddress = address || get().selectedAccount
        if (!targetAddress) {
          throw new Error("æ²¡æœ‰æŒ‡å®šè¦åˆ·æ–°çš„åœ°å€")
        }

        try {
          await get().fetchAllBalances(targetAddress)
          console.log(`ğŸ”„ ä½™é¢åˆ·æ–°æˆåŠŸ: ${targetAddress}`)
        } catch (error) {
          console.error("åˆ·æ–°ä½™é¢å¤±è´¥:", error)
          throw error
        }
      }
    }),
    {
      name: 'balance-store',
      partialize: (state) => ({
        balances: state.balances,
        selectedAccount: state.selectedAccount
      })
    }
  )
)

// å¯¼å‡ºç±»å‹
export type BalanceStoreType = ReturnType<typeof useBalanceStore>

// å·¥å…·å‡½æ•°
export const formatAddress = (address: string, length: number = 6): string => {
  if (!address || address.length < 10) return address
  return `${address.substring(0, length)}...${address.substring(address.length - 4)}`
}

export const formatUSD = (value: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 6
  }).format(value)
}

// è·å–å¸¸è§ä»£å¸åˆ—è¡¨
export const getCommonTokens = (chainId: string): Record<string, string> => {
  // ç›®å‰åªæ”¯æŒ Sepolia æµ‹è¯•ç½‘
  if (chainId === "11155111") {
    return COMMON_TOKENS
  }
  return {}
}